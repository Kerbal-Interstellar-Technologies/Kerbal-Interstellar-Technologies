<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)\bin\Debug\0_KerbalInterstellarTechnologies_Redist.dll" #>
<#@ assembly name="$(SolutionDir)\bin\Debug\KerbalInterstellarTechnologies.dll" #>
<#@ assembly name="$(SolutionDir)\bin\Debug\999_Scale_Redist.dll" #>
<#@ assembly name="$(SolutionDir)\bin\Debug\Assembly-CSharp.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ output extension=".cs" #>

/*

            uuuuuuuuuuuuuuuuuuuu
          u" uuuuuuuuuuuuuuuuuu "u
        u" u$$$$$$$$$$$$$$$$$$$$u "u
      u" u$$$$$$$$$$$$$$$$$$$$$$$$u "u
    u" u$$$$$$$$$$$$$$$$$$$$$$$$$$$$u "u
  u" u$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$u "u
u" u$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$u "u
$ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $
$ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $
$ $$$" ... "$...  ...$" ... "$$$  ... "$$$ $
$ $$$u `"$$$$$$$  $$$  $$$$$  $$  $$$  $$$ $
$ $$$$$$uu "$$$$  $$$  $$$$$  $$  """ u$$$ $
$ $$$""$$$  $$$$  $$$u "$$$" u$$  $$$$$$$$ $
$ $$$$....,$$$$$..$$$$$....,$$$$..$$$$$$$$ $
$ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $
"u "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$" u"
  "u "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$" u"
    "u "$$$$$$$$$$$$$$$$$$$$$$$$$$$$" u"
      "u "$$$$$$$$$$$$$$$$$$$$$$$$" u"
        "u "$$$$$$$$$$$$$$$$$$$$" u"
          "u """""""""""""""""" u"
            """"""""""""""""""""



DO NOT EDIT THIS FILE. IT IS GENERATED AUTOMATICALLY.
YOUR CHANGES WILL BE LOST. INSTEAD, EDIT KSPConfigStructs.tt
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
// using KerbalInterstellarTechnologies;

namespace KIT
{
    public enum ConfigStructType {
        Test,
        PartModule,
        ProtoPartModule
    }
}

<#
    string ConvertCollectionName(string input)
    {
            var pieces = input.Split('`');
            var firstPiece = pieces[0].Split('.').Last().Split('+').Last();
            
            if (pieces.Length == 1) return input;

            var firstIndex = pieces[1].IndexOf('[');
            var lastIndex = pieces[1].LastIndexOf(']');
            var subString = pieces[1].Substring(firstIndex + 1, lastIndex - firstIndex - 1);

            return $"{firstPiece}<{subString}>";
    }

    void BuildOutput(Assembly a)
    {
    	var types = a.GetTypes().OrderBy(t => t.Namespace).ToList();

        string[] stopFields = { "isEnabled", "moduleName" };

        string previousNamespace = "";

        foreach (var type in types) {
            if(type.Namespace == null || type.Namespace == "") continue;
            if(type.IsClass == false) continue;
            var fields = type.GetFields();
            bool foundKSPFieldAttribute = false;

            foreach (var f in fields) {
                object[] attrs = f.GetCustomAttributes(true);
                foreach (var attr in attrs) {
                    KSPField almost_there = attr as KSPField;
                    if(almost_there != null) {
                        foundKSPFieldAttribute = true;
                        break;
                    }
                }
                if(foundKSPFieldAttribute == true) break;
            }

            if(foundKSPFieldAttribute == false) continue;

            if(! previousNamespace.Equals(type.Namespace))
            {
                if(previousNamespace != "") {
#>
}
#endregion // <#= type.Namespace #>


<#
                }
#>
#region <#= type.Namespace #>
namespace <#= type.Namespace #>
{
<#
                previousNamespace = type.Namespace;
            }
#>

    class <#= type.Name #>Config
    {
        public ConfigStructType ConfigStructType => this._<#= type.Name #> != null ? ConfigStructType.PartModule : ConfigStructType.Test;
        private <#= type.Name #> _<#= type.Name #>;
        public <#= type.Name #>Config(<#= type.Name #> p = null) {
            _<#= type.Name #> = p;
        }
        
        <# var stopProcessing = false;
        foreach (var f in fields) { 
            foreach(var stupid in stopFields) if(stupid == f.Name) stopProcessing = true;
            if (stopProcessing) break;
            if(f.FieldType.IsNotPublic) continue;
            if(f.FieldType.IsNestedPrivate) continue;
            if(f.IsLiteral) continue;

            #>

        // Field: <#= f #> <#= f.Name #> 
        private <#= ConvertCollectionName(f.FieldType.ToString() /*FieldType.Name*/) #> _<#= f.Name #>;
        public <#= ConvertCollectionName(f.FieldType.ToString() /*FieldType.Name*/) #> <#= f.Name #> {
            get {
                if (_<#= type.Name #> != null) return _<#= type.Name #>.<#= f.Name #>;
                return _<#= f.Name #>;
            }
            set {
                if (_<#= type.Name #> != null) { _<#= type.Name #>.<#= f.Name #> = value; return; }
                _<#= f.Name #> = value;
            }
        }
<# } #>
    }
}
#endregion

<#
        }
    }

    var disabled = true;

    try
    {
        var assembly = typeof(KIT.BeamedPower.BeamConfiguration).Assembly;
        // var types = assembly.GetTypes();
        if(! disabled) BuildOutput(assembly);
    }
    catch (ReflectionTypeLoadException ex)
    {
        foreach(var le in ex.LoaderExceptions) {
#>
<#= le #>
<#
        }
    }

#>

// all done!
